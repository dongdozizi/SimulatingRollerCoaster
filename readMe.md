# Simulating a Roller Coaster

## Description
The project is to use Catmull-Rom splines along with OpenGL core profile shader-based texture mapping and Phong shading to create a roller coaster simulation.

## Results

Youtube link: https://www.youtube.com/shorts/_bupNbt5Yus

![Overview](HW2_Overview.jpg)

![SceneElement](SceneElements.jpg)

![TShaped](HW2_Tshaped.jpg)

![CollideDetect](CollideDetect.jpg)

## Core Credit Features

1. Uses OpenGL core profile, version 3.2 or higher - Y

2. Completed all Levels:
  Level 1 : - Y
  level 2 : - Y
  Level 3 : - Y
  Level 4 : - Y
  Level 5 : - Y

3. Rendered the camera at a reasonable speed in a continuous path/orientation - Y

4. Run at interactive frame rate (>15fps at 1280 x 720) - Y

5. Understandably written, well commented code - Y

6. Attached an Animation folder containing not more than 1000 screenshots - Y

7. Attached this ReadMe File - Y

## Extra Credit Features

1. Render a T-shaped rail cross section - Y
	Render a double T-shaped rail

2. Render a Double Rail - Y
	Render a double T-shaped rail

3. Made the track circular and closed it with C1 continuity - Y
	The track is closed and with C1 continuity by connect the last point with the first point

4. Any Additional Scene Elements? (list them here) - Y
	Image SceneElements.jpg have is an visualized explaination
	1. Railroad Tie under the rail
	2. Support wooden structure
	3. Connection between support structure and railroad tie.

5. Render a sky-box - Y
	There is a skyBox
 
6. Create tracks that mimic real world roller coaster - Y
	Mimic the real world roller coaster Hakugei (白鯨, White Whale) at Nagashima Spa Land in Mie Prefecture, Japan.
	Wiki: https://en.wikipedia.org/wiki/Hakugei_(roller_coaster)
	RIde video: https://www.youtube.com/watch?v=0F9Bunk2BrA
	To run this tack in MacOS, the command is ' ./hw2 splines/hakugei.sp splines/hakugei.up '

7. Generate track from several sequences of splines - N

8. Draw splines using recursive subdivision - Y
	The spline is generated by recursive subdivision

9. Render environment in a better manner - N

10. Improved coaster normals - Y
	Originally the coaster normals is generated by Sloan's method.
	The new normals is generated by the xxx.up file which includes the rotation angle of the spline tangent, the equation is 
		upVec = rotate( up , angle , ( tangent.x , 0 , tangent.z ) )
		binormal = cross ( tangent , up )
		normal = cross ( binormal , tangent )
	In the code I use interpolated angle.

11. Modify velocity with which the camera moves - Y
	Using the equation to modify velocity

12. Derive the steps that lead to the physically realistic equation of updating u - Y
	See pdf

## Additional Features

1. Rendered roller coaster with texture and light it up with phong shading, the count can be changed in bodyCount in the RollerCoaster struct.

2. Achieve collision detection in generating the support structure, which is the support of a higher rail cannot collide with lower rail with same x,z coordinates, there is a picture shown in CollideDetect.jpg.

3. There is three kinds of views:
	1) Front view: Sit in front of the first roller coaster cart and looking forward.
	2) Top view: The camera is looking at the center of the first roller coaster cart with a distance.
	3) free view: You can look the whole track and roller coaster cart freely in the world space.

4. In coding, structured each 3d object in an struct ThreeDimensionObject, and extend this object when using object.
	// 3D object struct
	struct ThreeDimensionObject {
  		PipelineProgram* pipelineProgram = nullptr; // pipeline program
   		 int numVertices; // number of vertices
      		int numElements; // number of elements
      		GLuint texHandle; // texture handle
      		VBO* vboVertices = nullptr; // VBO of vertices
      		VBO* vboTexCoord = nullptr; // VBO of texture coordinates
      		VBO* vboNormals = nullptr; // VBO of normals
      		VAO* vao = nullptr; // VAO
      		EBO* ebo = nullptr; // EBO of the object
  	};

## Open-Ended Problems

1. To solve the collision detection problem, I separate the rail to several pieces and each bounded with an rectangle box and it's heights, so the collision detection transformed into the collision between rectangle.

## Keyboard/Mouse controls

1. Move\stop the roller coaster: Press space '  ', initially the roller coaster are freezed unless press space ' ' to let it move.
2. Change the view type:
	'1'  : On the roller coaster. 
	'2  :  Look at the roller coaster. 
	'3' :  Free view.
3. Move in free view mode: 'w','a','s','d'.

